太好了！下面是**面试常见算法题清单**：每题含**问题描述**、**示例输入/输出**、以及可手写的 **Python 解法**。覆盖数组/字符串、双指针与滑窗、栈、二分、堆、链表、树/图、动态规划等高频考点。

------

## 1) Two Sum（两数之和）

**描述**：给定数组 `nums` 和目标值 `target`，返回两数下标使其和为 `target`（恰有一解）。
 **示例**：`nums=[2,7,11,15], target=9` → 输出 `[0,1]`

```python
def two_sum(nums, target):
    pos = {}
    for i, x in enumerate(nums):
        if target - x in pos:
            return [pos[target - x], i]
        pos[x] = i
```

------

## 2) Longest Substring Without Repeating Characters（无重复最长子串）

**描述**：返回字符串中不含重复字符的最长子串长度。
 **示例**：`"abcabcbb"` → `3`（"abc"）

```python
def lengthOfLongestSubstring(s):
    last, l, ans = {}, 0, 0
    for r, ch in enumerate(s):
        if ch in last and last[ch] >= l:
            l = last[ch] + 1
        last[ch] = r
        ans = max(ans, r - l + 1)
    return ans
```

------

## 3) Valid Parentheses（有效括号）

**描述**：只含 `()[]{}` 的字符串是否括号匹配。
 **示例**：`"({[]})"` → `True`

```python
def isValid(s):
    st, mp = [], {')':'(', ']':'[', '}':'{'}
    for c in s:
        if c in '([{': st.append(c)
        else:
            if not st or st.pop() != mp[c]: return False
    return not st
```

------

## 4) Merge Intervals（合并区间）

**描述**：合并重叠区间并返回。
 **示例**：`[[1,3],[2,6],[8,10],[15,18]]` → `[[1,6],[8,10],[15,18]]`

```python
def merge(intervals):
    intervals.sort()
    res = []
    for s, e in intervals:
        if not res or s > res[-1][1]:
            res.append([s, e])
        else:
            res[-1][1] = max(res[-1][1], e)
    return res
```

------

## 5) Product of Array Except Self（除自身外的乘积）

**描述**：返回每个位置“其他元素乘积”，要求 O(n)、不用除法。
 **示例**：`[1,2,3,4]` → `[24,12,8,6]`

```python
def productExceptSelf(nums):
    n, ans = len(nums), [1]*len(nums)
    p = 1
    for i in range(n):
        ans[i] = p; p *= nums[i]
    s = 1
    for i in range(n-1, -1, -1):
        ans[i] *= s; s *= nums[i]
    return ans
```

------

## 6) 3Sum（三数之和）

**描述**：找出数组中所有和为 0 的不重复三元组。
 **示例**：`[-1,0,1,2,-1,-4]` → `[[-1,-1,2],[-1,0,1]]`

```python
def threeSum(nums):
    nums.sort(); n=len(nums); res=[]
    for i in range(n):
        if i and nums[i]==nums[i-1]: continue
        l, r = i+1, n-1
        while l<r:
            s = nums[i]+nums[l]+nums[r]
            if s<0: l+=1
            elif s>0: r-=1
            else:
                res.append([nums[i], nums[l], nums[r]])
                l+=1; r-=1
                while l<r and nums[l]==nums[l-1]: l+=1
                while l<r and nums[r]==nums[r+1]: r-=1
    return res
```

------

## 7) Longest Palindromic Substring（最长回文子串）

**描述**：返回字符串中最长回文子串。
 **示例**：`"babad"` → `"bab"`（或 `"aba"`）

```python
def longestPalindrome(s):
    if not s: return ""
    L = R = 0
    def exp(l, r):
        nonlocal L, R
        while l>=0 and r<len(s) and s[l]==s[r]:
            if r-l > R-L: L, R = l, r
            l-=1; r+=1
    for i in range(len(s)):
        exp(i, i)      # 奇数中心
        exp(i, i+1)    # 偶数中心
    return s[L:R+1]
```

------

## 8) Binary Search（二分查找）

**描述**：在有序数组中查找目标，返回下标；不存在返回 -1。
 **示例**：`nums=[-1,0,3,5,9,12], target=9` → `4`

```python
def binary_search(nums, target):
    l, r = 0, len(nums)-1
    while l <= r:
        m = (l+r)//2
        if nums[m] == target: return m
        if nums[m] < target: l = m+1
        else: r = m-1
    return -1
```

------

## 9) Search in Rotated Sorted Array（旋转数组搜索）

**描述**：在**旋转有序数组**中查找目标，返回下标或 -1。
 **示例**：`[4,5,6,7,0,1,2], target=0` → `4`

```python
def search_rotated(nums, target):
    l, r = 0, len(nums)-1
    while l <= r:
        m = (l+r)//2
        if nums[m]==target: return m
        if nums[l] <= nums[m]:            # 左半有序
            if nums[l] <= target < nums[m]: r = m-1
            else: l = m+1
        else:                              # 右半有序
            if nums[m] < target <= nums[r]: l = m+1
            else: r = m-1
    return -1
```

------

## 10) Maximum Subarray（最大子数组和 / Kadane）

**描述**：找到连续子数组的最大和。
 **示例**：`[-2,1,-3,4,-1,2,1,-5,4]` → `6`（`[4,-1,2,1]`）

```python
def max_sub_array(nums):
    cur = ans = nums[0]
    for x in nums[1:]:
        cur = max(x, cur + x)
        ans = max(ans, cur)
    return ans
```

------

## 11) Trapping Rain Water（接雨水）

**描述**：给定柱状图，计算接雨水总量。
 **示例**：`[0,1,0,2,1,0,1,3,2,1,2,1]` → `6`

```python
def trap(height):
    l, r = 0, len(height)-1
    lm = rm = ans = 0
    while l < r:
        if height[l] < height[r]:
            lm = max(lm, height[l])
            ans += lm - height[l]
            l += 1
        else:
            rm = max(rm, height[r])
            ans += rm - height[r]
            r -= 1
    return ans
```

------

## 12) Top K Frequent Elements（前 K 高频元素）

**描述**：返回出现频率最高的 K 个元素。
 **示例**：`nums=[1,1,1,2,2,3], k=2` → `[1,2]`

```python
from collections import Counter
import heapq
def topKFrequent(nums, k):
    cnt = Counter(nums)
    return [x for x,_ in heapq.nlargest(k, cnt.items(), key=lambda p: p[1])]
```

------

## 13) Kth Largest in Array（数组第 K 大 / 快选）

**描述**：无序数组找第 K 大元素（1-indexed）。
 **示例**：`[3,2,1,5,6,4], k=2` → `5`

```python
import random
def findKthLargest(nums, k):
    k = len(nums) - k
    def sel(l, r):
        p = random.randint(l, r)
        nums[p], nums[r] = nums[r], nums[p]
        x = nums[r]; i = l
        for j in range(l, r):
            if nums[j] <= x:
                nums[i], nums[j] = nums[j], nums[i]; i += 1
        nums[i], nums[r] = nums[r], nums[i]
        if i == k: return nums[i]
        return sel(l, i-1) if i > k else sel(i+1, r)
    return sel(0, len(nums)-1)
```

------

## 14) Reverse Linked List（反转链表）

**描述**：反转单链表并返回新头结点。
 **示例**：`1->2->3->4->5` → `5->4->3->2->1`

```python
class ListNode:
    def __init__(self, x, nxt=None):
        self.val = x; self.next = nxt

def reverseList(head):
    prev = None; cur = head
    while cur:
        nxt = cur.next
        cur.next = prev
        prev = cur
        cur = nxt
    return prev
```

------

## 15) Binary Tree Level Order Traversal（二叉树层序遍历）

**描述**：返回二叉树的层序遍历（从上到下、每层左到右）。
 **示例**：`[3,9,20,null,null,15,7]` → `[[3],[9,20],[15,7]]`

```python
from collections import deque
class TreeNode:
    def __init__(self, x, l=None, r=None):
        self.val=x; self.left=l; self.right=r

def levelOrder(root):
    if not root: return []
    q, res = deque([root]), []
    while q:
        cur = []
        for _ in range(len(q)):
            node = q.popleft()
            cur.append(node.val)
            if node.left: q.append(node.left)
            if node.right: q.append(node.right)
        res.append(cur)
    return res
```

------

## 16) Course Schedule（课程表 / 拓扑排序检测环）

**描述**：有 `numCourses` 门课与先修关系 `prerequisites=[(a,b)]`（学 a 需先学 b）。判断能否完成所有课程（无环）。
 **示例**：`2, [[1,0]]` → `True`; `2, [[1,0],[0,1]]` → `False`

```python
from collections import defaultdict, deque
def canFinish(numCourses, prerequisites):
    g = defaultdict(list); indeg = [0]*numCourses
    for a,b in prerequisites:
        g[b].append(a); indeg[a]+=1
    q = deque(i for i in range(numCourses) if indeg[i]==0)
    seen = 0
    while q:
        u = q.popleft(); seen += 1
        for v in g[u]:
            indeg[v]-=1
            if indeg[v]==0: q.append(v)
    return seen == numCourses
```

------

## 17) Coin Change（硬币找零 / 最少硬币数）

**描述**：给定硬币面额 `coins` 和金额 `amount`，求凑出金额的最少硬币数；无解返回 `-1`。
 **示例**：`coins=[1,2,5], amount=11` → `3`（5+5+1）

```python
def coinChange(coins, amount):
    INF = amount+1
    dp = [0]+[INF]*amount
    for a in range(1, amount+1):
        for c in coins:
            if a-c >= 0:
                dp[a] = min(dp[a], dp[a-c]+1)
    return dp[amount] if dp[amount] != INF else -1
```

------

## 18) Longest Increasing Subsequence（最长递增子序列 O(n log n)）

**描述**：返回 LIS 的长度。
 **示例**：`[10,9,2,5,3,7,101,18]` → `4`（2,3,7,101）

```python
import bisect
def lengthOfLIS(nums):
    tails = []
    for x in nums:
        i = bisect.bisect_left(tails, x)
        if i == len(tails): tails.append(x)
        else: tails[i] = x
    return len(tails)
```

------

### 