# 知识图谱构建平台（面试版）

> **技术栈**：Python · Django/DRF · Neo4j · MySQL · Redis · Nginx · Docker Compose · RESTful API

------

## 1) 电梯陈述（面试用 30–60 秒）

- 我负责搭建一个“从文件到图谱”的端到端平台：解析供应商文件→抽取实体/关系→写入 Neo4j→通过 REST API 对外提供检索、可视化和治理能力。
- 核心亮点：可插拔的解析器、统一的图谱 Schema、批量导入 + 幂等写入、查询秒开（索引+缓存）、容器化一键部署。
- 结果：单批 10w+ 关系分钟级入库；典型查询 <200ms；上线后减少人工核对成本 70%+。

------

## 2) 总体架构

```
┌───────────┐   文件上传   ┌───────────────┐   Cypher/驱动   ┌─────────────┐
│  前端/调用方│──────────▶│  Django + DRF   │──────────────▶│   Neo4j 图库 │
└───────────┘   REST API  └───────────────┘   缓存/队列      └─────────────┘
                                   │                       ▲
                                   │元数据/审计            │
                                   ▼                       │
                              ┌─────────┐                   │
                              │  MySQL  │◀─────────────────┘
                              └─────────┘
                                   ▲
                                   │异步任务/缓存
                                   ▼
                              ┌─────────┐
                              │ Redis   │
                              └─────────┘
```

- **Django/DRF**：统一入口（上传、检索、删除、可视化数据接口）。
- **解析/抽取层**：支持 CSV/Excel/PDF/JSON；正则 + 规则引擎 + 可扩展 NLP（可选 spaCy）。
- **Neo4j**：存储实体/关系；建索引与约束；提供图查询（Cypher）。
- **MySQL**：审计、任务、文件元数据、权限/租户。
- **Redis**：任务队列（可选 Celery）、热点查询缓存。
- **Nginx**：反向代理与静态资源。
- **Docker Compose**：一键拉起全部服务。

------

## 3) 图谱 Schema（示例）

**节点**：`Supplier`（供应商）、`Product`（产品）、`Contract`（合同）、`Standard`（标准/法规）

**关系**：

- `(:Supplier)-[:SUPPLIES]->(:Product)`
- `(:Product)-[:BIND_BY]->(:Contract)`
- `(:Product)-[:COMPLIES_WITH]->(:Standard)`（合规）
- `(:Product)-[:VIOLATES]->(:Standard)`（不合规）

**关键属性**：

- Supplier{id, name, country}
- Product{id, name, model, category}
- Contract{id, no, signed_at, valid_to}
- Standard{id, code, title, version}

**索引与约束（Neo4j 5.x）**：

```cypher
CREATE CONSTRAINT supplier_id IF NOT EXISTS
FOR (s:Supplier) REQUIRE s.id IS UNIQUE;
CREATE INDEX product_name IF NOT EXISTS FOR (p:Product) ON (p.name);
CREATE CONSTRAINT standard_code IF NOT EXISTS
FOR (s:Standard) REQUIRE (s.code, s.version) IS UNIQUE;
```

------

## 4) 典型 API 设计（DRF）

- `POST /api/files/upload/`：上传原始文件，返回 `file_id`，异步触发解析入库。
- `GET  /api/graph/search?node=Product&name=xxx`：按条件检索节点/关系。
- `GET  /api/graph/neighbors/{node_id}?depth=2`：查看邻域，供前端可视化。
- `POST /api/graph/delete`：软删除节点/关系（带审计）。
- `GET  /api/standards/check?product_id=...`：基于规则做合规校验，返回不合格项。

**返回风格**：统一 `code/msg/data`，并包含 `trace_id` 方便观测。

------

## 5) 代码骨架（关键片段）

> 仅展示核心思路，便于面试讲解与白板推演。

### 5.1 requirements.txt（节选）

```txt
Django>=5.0
djangorestframework>=3.15
mysqlclient>=2.2
neo4j>=5.20
redis>=5.0
celery>=5.4  # 可选
python-multipart>=0.0.9
pandas>=2.2
openpyxl>=3.1
PyPDF2>=3.0
```

### 5.2 settings.py（与环境变量解耦）

```python
import os
NEO4J_URI = os.getenv("NEO4J_URI", "bolt://neo4j:7687")
NEO4J_USER = os.getenv("NEO4J_USER", "neo4j")
NEO4J_PASS = os.getenv("NEO4J_PASS", "password")
MYSQL_DSN  = {
    'ENGINE':'django.db.backends.mysql',
    'NAME': os.getenv('MYSQL_DB','kg_meta'),
    'USER': os.getenv('MYSQL_USER','kg_user'),
    'PASSWORD': os.getenv('MYSQL_PASS','kg_pass'),
    'HOST': os.getenv('MYSQL_HOST','mysql'),
    'PORT': os.getenv('MYSQL_PORT','3306'),
}
REDIS_URL  = os.getenv("REDIS_URL","redis://redis:6379/0")
```

### 5.3 Neo4j 驱动封装

```python
# apps/graph/neo4j_driver.py
from neo4j import GraphDatabase
import os

driver = GraphDatabase.driver(
    os.getenv("NEO4J_URI"),
    auth=(os.getenv("NEO4J_USER"), os.getenv("NEO4J_PASS"))
)

def run_cypher(query:str, params:dict=None):
    with driver.session() as session:
        return session.execute_write(lambda tx: list(tx.run(query, **(params or {}))))
```

### 5.4 MySQL 模型（审计/文件/任务）

```python
# apps/meta/models.py
from django.db import models

class UploadFile(models.Model):
    id = models.BigAutoField(primary_key=True)
    filename = models.CharField(max_length=255)
    path = models.CharField(max_length=512)
    uploader = models.CharField(max_length=128)
    status = models.CharField(max_length=32, default='PENDING')  # PENDING/PROCESSING/DONE/FAILED
    created_at = models.DateTimeField(auto_now_add=True)

class AuditLog(models.Model):
    action = models.CharField(max_length=64)
    actor = models.CharField(max_length=128)
    detail = models.JSONField(default=dict)
    created_at = models.DateTimeField(auto_now_add=True)
```

### 5.5 抽取/入库（CSV/Excel 示例）

```python
# apps/ingest/parsers.py
import pandas as pd
from .rules import to_nodes_and_rels
from apps.graph.neo4j_driver import run_cypher

MERGE_STMT = """
UNWIND $nodes AS n
CALL apoc.merge.node([n.label], n.keys, n.props) YIELD node
RETURN count(node) AS created
"""

MERGE_RELS = """
UNWIND $rels AS r
MATCH (s) WHERE s.id = r.start_id
MATCH (t) WHERE t.id = r.end_id
CALL apoc.merge.relationship(s, r.type, {}, {}, t) YIELD rel
RETURN count(rel) AS created
"""

def ingest_products_excel(path:str):
    df = pd.read_excel(path)
    nodes, rels = to_nodes_and_rels(df)
    run_cypher(MERGE_STMT, {"nodes": nodes})
    run_cypher(MERGE_RELS, {"rels": rels})
# apps/ingest/rules.py
# 将表格行映射为图谱节点/关系（示例）

def to_nodes_and_rels(df):
    nodes, rels = [], []
    for _, row in df.iterrows():
        supplier_id = f"SUP-{row['SupplierCode']}"
        product_id  = f"PRD-{row['ProductCode']}"
        nodes += [
            {"label":"Supplier", "keys":{"id": supplier_id},
             "props":{"name": row['SupplierName'], "country": row.get('Country','')}},
            {"label":"Product",  "keys":{"id": product_id},
             "props":{"name": row['ProductName'], "model": row.get('Model','')}}
        ]
        rels.append({
            "type":"SUPPLIES", "start_id": supplier_id, "end_id": product_id
        })
    return nodes, rels
```

### 5.6 DRF 视图（上传→异步处理→查询）

```python
# apps/api/views.py
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from django.core.files.storage import default_storage
from apps.meta.models import UploadFile, AuditLog
from apps.ingest.parsers import ingest_products_excel
from apps.graph.neo4j_driver import run_cypher
import uuid, os

class UploadView(APIView):
    def post(self, request):
        f = request.FILES['file']
        fname = f"{uuid.uuid4()}_{f.name}"
        path = default_storage.save(fname, f)
        rec = UploadFile.objects.create(filename=f.name, path=path, uploader=str(request.user))
        try:
            # 简化：直接处理；生产建议 Celery 异步
            if f.name.endswith((".xlsx",".xls")):
                ingest_products_excel(default_storage.path(path))
            rec.status = 'DONE'; rec.save()
            AuditLog.objects.create(action='UPLOAD', actor=str(request.user), detail={"file": f.name})
            return Response({"code":0, "msg":"ok", "data":{"file_id": rec.id}})
        except Exception as e:
            rec.status = 'FAILED'; rec.save()
            return Response({"code":1, "msg": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

class SearchView(APIView):
    def get(self, request):
        node = request.GET.get('node','Product')
        name = request.GET.get('name','')
        q = f"MATCH (n:{node}) WHERE toLower(n.name) CONTAINS toLower($name) RETURN n LIMIT 50"
        rows = run_cypher(q, {"name": name})
        data = [dict(r[0]) for r in rows]
        return Response({"code":0, "msg":"ok", "data":data})
```

### 5.7 常用 Cypher 查询（面试可白板写）

```cypher
// 查询产品的供应链上下游
MATCH (s:Supplier)-[r:SUPPLIES]->(p:Product {id:$pid})
OPTIONAL MATCH (p)-[:BIND_BY]->(c:Contract)
RETURN s, r, p, c;

// 合规核查：找未满足指定标准的产品
MATCH (p:Product)
WHERE NOT (p)-[:COMPLIES_WITH]->(:Standard {code:$code})
RETURN p LIMIT 100;
```

------

## 6) Docker & 部署

### 6.1 docker-compose.yml（精简示例）

```yaml
version: '3.9'
services:
  web:
    build: ./backend
    env_file: .env
    depends_on: [mysql, neo4j, redis]
    ports: ["8000:8000"]
  nginx:
    image: nginx:alpine
    volumes:
      - ./deploy/nginx.conf:/etc/nginx/conf.d/default.conf:ro
    ports: ["80:80"]
    depends_on: [web]
  mysql:
    image: mysql:8
    environment:
      - MYSQL_DATABASE=kg_meta
      - MYSQL_USER=kg_user
      - MYSQL_PASSWORD=kg_pass
      - MYSQL_ROOT_PASSWORD=root
    ports: ["3306:3306"]
  neo4j:
    image: neo4j:5-community
    environment:
      - NEO4J_AUTH=neo4j/password
      - NEO4JLABS_PLUGINS=["apoc"]
    ports: ["7474:7474","7687:7687"]
  redis:
    image: redis:7-alpine
    ports: ["6379:6379"]
```

### 6.2 backend/Dockerfile

```dockerfile
FROM python:3.11-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .
EXPOSE 8000
CMD ["python","manage.py","runserver","0.0.0.0:8000"]
```

### 6.3 Nginx 反代配置（deploy/nginx.conf）

```nginx
server {
  listen 80;
  location / { proxy_pass http://web:8000; }
}
```

### 6.4 一键部署脚本（deploy/deploy.sh）

```bash
#!/usr/bin/env bash
set -e
export COMPOSE_PROJECT_NAME=kg
docker compose pull || true
docker compose build
docker compose up -d
# 初始化 Neo4j 约束（可选：在应用启动时执行）
# docker compose exec web python manage.py init_graph
```

------

## 7) 安全、治理与可观测

- **安全**：JWT 鉴权、租户隔离；上传白名单 + 文件型安全扫描；读写分级（删除需要二次确认 + 审计）。
- **数据质量**：入库幂等（MERGE）、重复检测、必填校验、规则引擎（正则/阈值/NLP 模式）。
- **可观测**：统一 `trace_id`、请求日志/慢查询、Neo4j Profile、Prometheus（可选）。
- **性能**：节点/属性索引 + 热点缓存；批量 `UNWIND` 导入；异步任务（Celery）。

------

## 8) 演示用 cURL（面试可快速展示）

```bash
# 1) 上传 Excel
curl -F "file=@samples/products.xlsx" http://localhost/api/files/upload/

# 2) 检索产品
curl "http://localhost/api/graph/search?node=Product&name=filter"

# 3) 查看邻域
curl "http://localhost/api/graph/neighbors/PRD-1001?depth=2"
```

------

## 9) 可视化思路（前端或 Notebook）

- 返回 `nodes:[{id,label,props}], edges:[{source,target,type}]`，前端用 `echarts/graphin/d3-force` 展示。
- 提供局部展开（按关系类型/深度）、高亮路径、导出 PNG/SVG。

------

## 10) 面试 Q&A 备选

- **为什么同时用 MySQL 和 Neo4j？** 分工：MySQL 做事务型元数据/审计/权限，Neo4j 做关系计算与检索。
- **如何保证入库幂等与一致性？** `MERGE` + 业务主键 + 事务；失败回滚并记录审计。
- **如何做大批量导入优化？** `UNWIND` 批处理、禁用冗余日志、先建索引后导入、必要时使用 `neo4j-admin import`。
- **如何扩展新的文件格式？** 解析器接口化：新增 `parser` 只需产出统一的 `nodes/rels`。
- **如何做合规校验？** 将法规/标准抽象为 `Standard` 节点 + 规则，解析产品属性对照生成 `COMPLIES_WITH/VIOLATES` 关系并出报告。